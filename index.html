<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Presence</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
html, body {
  margin: 0;
  padding: 0;
  background: #05050a;
  overflow: hidden;
  font-family: system-ui, -apple-system, BlinkMacSystemFont;
}
#overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle, #0c0c18, #05050a);
  display: flex;
  align-items: center;
  justify-content: center;
  color: #eaeaea;
  cursor: pointer;
  z-index: 10;
}
#overlay div { text-align: center; }
#overlay h1 { font-weight: 500; letter-spacing: 2px; }
#overlay p  { font-size: 0.85rem; color: #aaa; letter-spacing: 1px; }
canvas { display: block; }
</style>
</head>

<body>
<div id="overlay">
  <div>
    <h1>Tap to begin</h1>
    <p>sound reveals intent</p>
  </div>
</div>

<canvas id="c"></canvas>

<script>
// ==========================
// ðŸ”´ PERSONALIZATION
// ==========================
const HER_NAME   = "Naina";
const HER_MSG    = "this was always for you";
const FINAL_LINE = "and I wanted you to feel it";
// ==========================

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let w, h;
function resize() {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// ---------------- AUDIO ----------------
let audioCtx, analyser, dataArray;
let started = false;

document.getElementById("overlay").onclick = async () => {
  document.getElementById("overlay").remove();
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const src = audioCtx.createMediaStreamSource(stream);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 256;
  dataArray = new Uint8Array(analyser.frequencyBinCount);
  src.connect(analyser);
  started = true;
};

// ---------------- ORBS ----------------
class Orb {
  constructor() {
    this.a = Math.random() * Math.PI * 2;
    this.r = Math.random() * Math.min(w, h) * 0.4;
    this.s = 0.001 + Math.random() * 0.002;
  }
  update(e) { this.a += this.s * (1 + e * 0.02); }
  draw(e, warm) {
    const x = w/2 + Math.cos(this.a) * (this.r + e * 1.2);
    const y = h/2 + Math.sin(this.a) * (this.r + e * 1.2);
    ctx.beginPath();
    ctx.arc(x, y, 2 + e * 0.04, 0, Math.PI * 2);
    ctx.fillStyle = warm
      ? `rgba(244,180,200,${0.6 + e * 0.002})`
      : `rgba(180,180,255,0.4)`;
    ctx.fill();
  }
}
const orbs = Array.from({ length: 220 }, () => new Orb());

// ---------------- STATE ----------------
let locked = false;
let revealAt = 0;

let typedChars = 0;
const TYPE_SPEED = 18;

let finished = false;
let finishedAt = 0;

// ---------------- LOOP ----------------
function animate(ts) {
  ctx.fillStyle = "rgba(5,5,10,0.25)";
  ctx.fillRect(0, 0, w, h);

  let energy = 0;
  if (started) {
    analyser.getByteFrequencyData(dataArray);
    energy = dataArray.reduce((s,v)=>s+v,0) / dataArray.length;
  }

  const revealProgress = Math.min(energy / 30, 1);
  const triggerName = revealProgress > 0.8;

  if (triggerName && !locked) {
    locked = true;
    revealAt = ts;
  }

  orbs.forEach(o => {
    if (!finished) o.update(energy);
    o.draw(energy, locked);
  });

  // -------- NAME --------
  ctx.save();
  ctx.fillStyle = "white";
  ctx.font = "42px system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(locked ? HER_NAME : "stay here", w/2, h/2 - 12);
  ctx.restore();

  // -------- TYPEWRITER --------
  if (locked && !finished) {
    const elapsed = (ts - revealAt) / 1000;
    if (elapsed > 1.5) {
      typedChars = Math.min(
        HER_MSG.length,
        Math.floor((elapsed - 1.5) * TYPE_SPEED)
      );
    }

    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "16px system-ui";
    ctx.textAlign = "center";
    ctx.fillText(
      HER_MSG.slice(0, typedChars),
      w/2,
      h/2 + 28
    );
    ctx.restore();

    if (typedChars === HER_MSG.length) {
      finished = true;
      finishedAt = ts;
    }
  }

  // -------- FINAL PAYOFF (DELAYED) --------
  if (finished) {
    const t = (ts - finishedAt) / 1000;

    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(0, 0, w, h);

    const pulse = 0.5 + 0.5 * Math.sin(ts / 260);
    ctx.globalAlpha = pulse;
    ctx.strokeStyle = "rgba(255,180,200,0.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(w/2, h/2, 90 + pulse * 10, 0, Math.PI * 2);
    ctx.stroke();

    if (t > 0.8) {
      ctx.globalAlpha = Math.min((t - 0.8), 1);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "17px system-ui";
      ctx.textAlign = "center";
      ctx.fillText(FINAL_LINE, w/2, h/2 + 70);
    }
    ctx.restore();
  }

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</script>
</body>
</html>

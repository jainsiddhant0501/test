<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Presence</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
html, body {
  margin: 0;
  padding: 0;
  background: #05050a;
  overflow: hidden;
  font-family: system-ui, -apple-system, BlinkMacSystemFont;
}
#overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle, #0c0c18, #05050a);
  display: flex;
  align-items: center;
  justify-content: center;
  color: #eaeaea;
  cursor: pointer;
  z-index: 10;
}
canvas { display: block; }
</style>
</head>

<body>
<div id="overlay"><h2>Tap to begin</h2></div>
<canvas id="c"></canvas>

<script>
// ================== PERSONALIZE ==================
const HER_NAME   = "Naina";
const HER_MSG    = "this was always for you";
const FINAL_LINE = "and I wanted you to feel it";
// =================================================

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let w, h;
function resize() {
  w = canvas.width = innerWidth;
  h = canvas.height = innerHeight;
}
addEventListener("resize", resize);
resize();

// ---------------- AUDIO ----------------
let audioCtx, analyser, dataArray;
let micStarted = false;

overlay.onclick = async () => {
  overlay.remove();
  audioCtx = new (AudioContext || webkitAudioContext)();
  const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
  const src = audioCtx.createMediaStreamSource(stream);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 256;
  dataArray = new Uint8Array(analyser.frequencyBinCount);
  src.connect(analyser);
  micStarted = true;
};

// ---------------- HEART POINTS ----------------
function generateHeartOutline(cx, cy, scale, count) {
  const pts = [];
  for (let i = 0; i < count; i++) {
    const t = (i / count) * Math.PI * 2;
    const x = 16 * Math.pow(Math.sin(t), 3);
    const y =
      13 * Math.cos(t)
      - 5 * Math.cos(2*t)
      - 2 * Math.cos(3*t)
      - Math.cos(4*t);
    pts.push({
      x: cx + x * scale,
      y: cy - y * scale
    });
  }
  return pts;
}

// ---------------- PARTICLES ----------------
class Particle {
  constructor() {
    this.x = Math.random() * w;
    this.y = Math.random() * h;
    this.tx = this.x;
    this.ty = this.y;
  }
  setTarget(p) {
    this.tx = p.x;
    this.ty = p.y;
  }
  update(active) {
    if (!active) return;
    this.x += (this.tx - this.x) * 0.08;
    this.y += (this.ty - this.y) * 0.08;
  }
  draw() {
    ctx.beginPath();
    ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(244,180,200,0.9)";
    ctx.fill();
  }
}

const COUNT = 240;
const particles = Array.from({ length: COUNT }, () => new Particle());

// ---------------- STATE ----------------
let typed = 0;
let messageDone = false;
let heartReady = false;

let heartCenterY = 0;

// ---------------- LOOP ----------------
function animate(ts) {
  ctx.fillStyle = "rgba(5,5,10,0.25)";
  ctx.fillRect(0, 0, w, h);

  // ---------- NAME (NO HANG POSSIBLE) ----------
  const nameY = heartReady ? heartCenterY + 6 : h / 2;

  ctx.fillStyle = "white";
  ctx.font = "42px system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(
    micStarted ? HER_NAME : "stay here",
    w / 2,
    nameY
  );

  // ---------- MESSAGE ----------
  if (micStarted && !messageDone) {
    typed = Math.min(HER_MSG.length, typed + 0.4);
    ctx.font = "16px system-ui";
    ctx.fillText(HER_MSG.slice(0, Math.floor(typed)), w / 2, h / 2 + 40);

    if (typed >= HER_MSG.length) {
      messageDone = true;

      // define heart ONCE
      heartCenterY = h / 2 - 30;
      const targets = generateHeartOutline(w / 2, heartCenterY, 6, COUNT);
      particles.forEach((p, i) => p.setTarget(targets[i]));
      heartReady = true;
    }
  }

  // ---------- PARTICLES ----------
  particles.forEach(p => {
    p.update(heartReady);
    p.draw();
  });

  // ---------- FINAL LINE ----------
  if (heartReady) {
    ctx.font = "17px system-ui";
    ctx.fillText(FINAL_LINE, w / 2, heartCenterY + 60);
  }

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</script>
</body>
</html>
